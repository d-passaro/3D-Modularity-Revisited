{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Example section companion notebook\n",
    "\n",
    "This notebook demonstrates the results of subsection 5.1.2 of [1]. Here, we will compute the $\\hat{Z}$ invariant of the Seifert manifold $M(-2;\\frac{1}{2},\\frac{2}{3},\\frac{2}{3})$, we will calculate the associated Weil representation and we will verify that through Wilson line insertion we can complete the representation. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "vscode": {
     "languageId": "sage"
    }
   },
   "source": [
    "## Defect $\\hat{Z}$ invariants\n",
    "\n",
    "Here we compute the $\\hat{Z}$ invariants with and without defects of the manifold. We do so using pyPlumbing. To that end, we import the Plumbing class and define a Plumbing as a Seifert manifold."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "vscode": {
     "languageId": "sage"
    }
   },
   "outputs": [
    {
     "data": {
      "image/png": "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",
      "text/plain": [
       "Graphics object consisting of 12 graphics primitives"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from pyPlumbing import Plumbing\n",
    "P = Plumbing.from_Seifert_data([-2,1/2,2/3,2/3])\n",
    "P.display()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "PyPlumbing provides functionality to compute the $\\hat{Z}$ invariant. With trivial boundary conditions and Wilson line insersions in the heighest weight representations (0), (1) on the node $v_5$ we obtain:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "vscode": {
     "languageId": "sage"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "b = [ 1 -1  0 -1  0 -1]\n",
      "  w = [(0), (0), (0), (0), (0), (0)]\n",
      "  zh = q^(-1)(4 - 4q^(1) + 4q^(2) + 4q^(5) - 4q^(7) - 4q^(12) + 4q^(15) + 4q^(22) - 4q^(26) - 4q^(35) + O(q^40))\n",
      "  w = [(0), (0), (0), (0), (0), (1)]\n",
      "  zh = q^(5667/2000)(4 - 4q^(6) + 4q^(15) - 4q^(27) + O(q^28))\n",
      "b = [ 3 -1 -2 -1  0 -3]\n",
      "  w = [(0), (0), (0), (0), (0), (0)]\n",
      "  zh = q^(-1333/2000)(-4 + 4q^(3) - 4q^(9) + 4q^(18) + O(q^19))\n",
      "  w = [(0), (0), (0), (0), (0), (1)]\n",
      "  zh = q^(5667/2000)(4 - 4q^(6) + 4q^(15) - 4q^(27) + O(q^28))\n"
     ]
    }
   ],
   "source": [
    "\n",
    "group_rank = [\"A\",1]\n",
    "b0,b1 = P.spin_c(group_rank)\n",
    "print(\"b = %s\" % b0.T)\n",
    "for w in range(2):\n",
    "    W = [vector([0])]*5 + [vector([w])]\n",
    "    print(\"  w = %s\" % W)\n",
    "    zh = P.zhat(group_rank, b0, 20, wilson=W)\n",
    "    print(\"  zh = %s\" % zh)\n",
    "    \n",
    "print(\"b = %s\" % b1.T)\n",
    "for w in range(2):\n",
    "    W = [vector([0])]*5 + [vector([w])]\n",
    "    print(\"  w = %s\" % W)\n",
    "    zh = P.zhat(group_rank, b1, 20, wilson=W)\n",
    "    print(\"  zh = %s\" % zh)\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Weil Representation\n",
    "\n",
    "We wish to compare the $\\hat{Z}$ $q$-power expansions with the $q$-series expansions of the linear combinations of false theta functions associated to the Weil representation. To that end we import the functions of weyl_rep_fncs.sage which provide the necessary functionality."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "vscode": {
     "languageId": "sage"
    }
   },
   "outputs": [],
   "source": [
    "m = 2*3\n",
    "K = [1,3]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "vscode": {
     "languageId": "sage"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "index = 1\n",
      "theta_{1}^{m+K} = -theta(6, 11) - theta(6, 7) + theta(6, 5) + theta(6, 1)\n",
      "theta_{1}^{m+K} = 2*q^(1/24)*(1.0 + 1*q + (-1.0)*q^2 + (-1.0)*q^5 + 1*q^7 + 1*q^12 + (-1.0)*q^15 + Order(q^20))\n",
      "index = 3\n",
      "theta_{3}^{m+K} = -theta(6, 9) + theta(6, 3)\n",
      "theta_{3}^{m+K} = 2*q^(3/8)*(1.0 + (-1.0)*q^3 + 1*q^9 + (-1.0)*q^18 + Order(q^20))\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "load(\"weil_rep_fncs.sage\")\n",
    "proj = weil_projector(m,K)\n",
    "ind = [np.arange(2*m)[p != 0] for p in proj if len(np.arange(2*m)[p != 0]>0)]\n",
    "signs = [np.sign((p)[ p != 0]) for p in proj if len(np.arange(2*m)[p != 0]>0)]\n",
    "reps = list()\n",
    "rep_sgns = list()\n",
    "for rep,sgn in zip(ind,signs):\n",
    "    if not list(rep) in reps:\n",
    "        reps += [list(rep)]\n",
    "        rep_sgns += [list(sgn)]\n",
    "th = function('theta', nargs=2)\n",
    "for rep,rep_sgn in zip(reps,rep_sgns):\n",
    "    print(\"index = %s\" % rep[0])\n",
    "    print(\"theta_{\"+str(rep[0])+\"}^{m+K} = %s\" % sum(int(s)*th(m,r) for r,s in zip(rep,rep_sgn)))\n",
    "    theta_expansion = 0\n",
    "    for r,s in zip(rep,rep_sgn):\n",
    "        theta_expansion += s*false_theta(m,int(r),20)\n",
    "    print(\"theta_{\"+str(rep[0])+\"}^{m+K} = %s\" % format_expansion(theta_expansion))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "vscode": {
     "languageId": "sage"
    }
   },
   "source": [
    "## Bibliography\n",
    "[1] Cheng Et al, 3D Modularity Revisited, ArXiv 2403.14920"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "SageMath 10.3",
   "language": "sage",
   "name": "sagemath"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.5"
  },
  "vscode": {
   "interpreter": {
    "hash": "e7370f93d1d0cde622a1f8e1c04877d8463912d04d973331ad4851f04de6915a"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
