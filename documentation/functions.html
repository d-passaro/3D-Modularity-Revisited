

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Modularity Revisited Documentation &mdash; 3D Modularity Revisited 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css?v=71331e4b" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8d563738"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Examples" href="examples.html" />
    <link rel="prev" title="Theorems and Conjectures" href="theorems.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="index.html" class="icon icon-home">
            3D Modularity Revisited
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="theorems.html">Theorems and Conjectures</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3D Modularity Revisited Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">3D Modularity Revisited</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">3D Modularity Revisited Documentation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/functions.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="d-modularity-revisited-documentation">
<h1>3D Modularity Revisited Documentation<a class="headerlink" href="#d-modularity-revisited-documentation" title="Link to this heading"></a></h1>
<p id="module-3d_modularity_revisited">This document describes all functions implemented in the <code class="docutils literal notranslate"><span class="pre">3d_modularity_revisited.sage</span></code> module.</p>
<p>This module contains functions for computing Weil representations and related modular forms for 3D modularity. The functions implement mathematical objects used in the study of mock theta functions and their modular properties.</p>
<p>Key components:</p>
<ul class="simple">
<li><p>Weil representation matrices and projectors</p></li>
<li><p>False theta series and mock theta functions</p></li>
<li><p>Indefinite theta functions</p></li>
<li><p>Ramanujan’s order 7 mock theta functions</p></li>
</ul>
<p>Mathematical background: These functions implement results from algebraic number theory and modular forms, particularly focused on Weil representations of quadratic forms and their applications to mock theta functions.</p>
<section id="weil-representation-functions">
<h2>Weil Representation Functions<a class="headerlink" href="#weil-representation-functions" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.omega">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">omega</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.omega" title="Link to this definition"></a></dt>
<dd><p>Compute the matrix <img class="math" src="_images/math/a3813d3c528fc140f2acad89e68261f81b639a2c.png" alt="\omega_{m,n}"/> of the Weil representation.</p>
<p>This function constructs a fundamental matrix in the Weil representation that encodes the action of certain transformations on theta functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – Primary modulus parameter</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Secondary modulus parameter, must divide m</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <img class="math" src="_images/math/8b18eea725e1373d837d1142024e06b1ba2d59e7.png" alt="(2m \times 2m)"/> matrix representing <img class="math" src="_images/math/a3813d3c528fc140f2acad89e68261f81b639a2c.png" alt="\omega_{m,n}"/></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Matrix</p>
</dd>
</dl>
<p><strong>Mathematical Reference:</strong> See [1] around equation (2.35) for mathematical details.</p>
<p><strong>Notes:</strong> The matrix entries are determined by congruence conditions: <img class="math" src="_images/math/d9b5e171c962d114ba3592de279fb73a8fe761fb.png" alt="\omega[i,j] = 1"/> if <img class="math" src="_images/math/191b7aa23fe00750135702a49aea4f344c2bc42b.png" alt="(i+j) \equiv 0 \pmod{2n}"/> and <img class="math" src="_images/math/61055f67a6ef3a173721c75f48a9c04f1770c287.png" alt="(i-j) \equiv 0 \pmod{2m/n}"/>, otherwise <img class="math" src="_images/math/1b80f7a827762481485ca6f782e4731175fdfdd9.png" alt="\omega[i,j] = 0"/>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.p_plus">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">p_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.p_plus" title="Link to this definition"></a></dt>
<dd><p>Compute the positive projection matrix <img class="math" src="_images/math/4840dc1d0935e2ae744147c207d26ebd35f224a0.png" alt="P_{m,n}^+"/> of the Weil representation.</p>
<p>This projector extracts the ‘+1 eigenspace’ of the omega matrix, which corresponds to certain symmetries in the theta functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – Primary modulus parameter</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Secondary modulus parameter</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The positive projection matrix <img class="math" src="_images/math/84732032f2380b91dfe6915bd2518543237f7a76.png" alt="P_{m,n}^+ = (I + \omega_{m,n})/2"/></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Matrix</p>
</dd>
</dl>
<p><strong>Mathematical Reference:</strong> See [1] around equation (2.36) for details.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.p_minus">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">p_minus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.p_minus" title="Link to this definition"></a></dt>
<dd><p>Compute the negative projection matrix <img class="math" src="_images/math/53f3e3d52c2f9d9e3a8cebeae32c1f0efeb9c2c5.png" alt="P_{m,n}^-"/> of the Weil representation.</p>
<p>This projector extracts the ‘-1 eigenspace’ of the omega matrix, which corresponds to antisymmetric components in the theta functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – Primary modulus parameter</p></li>
<li><p><strong>n</strong> (<em>int</em>) – Secondary modulus parameter</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The negative projection matrix <img class="math" src="_images/math/5e344735c5457998fd8a18b3484223d4ba2a72ba.png" alt="P_{m,n}^- = (I - \omega_{m,n})/2"/></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Matrix</p>
</dd>
</dl>
<p><strong>Mathematical Reference:</strong> See [1] around equation (2.36) for details.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.weil_projector">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">weil_projector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.weil_projector" title="Link to this definition"></a></dt>
<dd><p>Compute the complete projector for the Weil representation for subset K.</p>
<p>This function constructs the main projector by composing positive projections for each element in K, followed by optional irreducible representation adjustments and a final negative projection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – Primary modulus parameter</p></li>
<li><p><strong>K</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – Subset of divisors to project onto</p></li>
<li><p><strong>irrep</strong> (<em>bool</em>) – Whether to apply irreducible representation corrections</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The complete Weil projector matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p><strong>Mathematical Reference:</strong> See [1] around equation (2.39) for details.</p>
<p><strong>Algorithm:</strong></p>
<ol class="arabic simple">
<li><p>Start with identity matrix</p></li>
<li><p>Apply positive projections for each n in K</p></li>
<li><p>If irrep=True, apply corrections for square divisors</p></li>
<li><p>Apply final negative projection</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.weil_reps">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">weil_reps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.weil_reps" title="Link to this definition"></a></dt>
<dd><p>Extract Weil representation data from the projector.</p>
<p>This function computes the projector and extracts the non-zero components along with their signs, identifying the irreducible representations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – Primary modulus parameter</p></li>
<li><p><strong>K</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – Subset of divisors</p></li>
<li><p><strong>irrep</strong> (<em>bool</em>) – Whether to use irreducible representation</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple containing list of index lists for each representation and list of sign lists for each representation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[List[List[int]], List[List[int]]]</p>
</dd>
</dl>
<p><strong>Notes:</strong> This function identifies unique representations by finding rows of the projector with non-zero entries and extracting their support and signs.</p>
</dd></dl>

</section>
<section id="theta-series-functions">
<h2>Theta Series Functions<a class="headerlink" href="#theta-series-functions" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.false_theta">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">false_theta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">var('q')</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.false_theta" title="Link to this definition"></a></dt>
<dd><p>Compute the false theta series <img class="math" src="_images/math/65d51fe714ae76974317972f0e06caa43e72da83.png" alt="\psi_{m,r}(q)"/>.</p>
<p>False theta series are q-series that appear in the study of mock theta functions and have applications in partition theory and modular forms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – Modulus parameter</p></li>
<li><p><strong>r</strong> (<em>int</em>) – Residue class parameter</p></li>
<li><p><strong>max_n</strong> (<em>int</em>) – Maximum summation index (series truncated at ±max_n)</p></li>
<li><p><strong>q</strong> (<em>SymbolicExpression</em>) – Formal variable (default: var(“q”))</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The false theta series <img class="math" src="_images/math/00305a2795b1e84061271fa7d401bf31d73b1d78.png" alt="\psi_{m,r}(q) = \sum_{n=-\mathrm{max\_n}}^{\mathrm{max\_n}} \mathrm{sign}(r + 2mn) \cdot q^{(r + 2mn)^2/(4m)}"/></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SymbolicExpression</p>
</dd>
</dl>
<p><strong>Notes:</strong> The ‘round(sign(k))’ gives 0 for k=0, ±1 for k≠0, which differs from the standard sign function that gives 0 for k=0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.Psi">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">Psi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">var('q')</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.Psi" title="Link to this definition"></a></dt>
<dd><p>Compute the Psi theta series (alternative form).</p>
<p>This is similar to false_theta but uses the standard sign function instead of the rounded version.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – Modulus parameter</p></li>
<li><p><strong>r</strong> (<em>int</em>) – Residue class parameter</p></li>
<li><p><strong>max_n</strong> (<em>int</em>) – Maximum summation index</p></li>
<li><p><strong>q</strong> (<em>SymbolicExpression</em>) – Formal variable</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Psi series <img class="math" src="_images/math/5bb157efee8006798d1c89b999dbf676005d5ef4.png" alt="\Psi_{m,r}(q) = \sum_{n=-\mathrm{max\_n}}^{\mathrm{max\_n}} \mathrm{sign}(r + 2mn) \cdot q^{(r + 2mn)^2/(4m)}"/></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SymbolicExpression</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.unary_theta">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">unary_theta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">var('q')</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.unary_theta" title="Link to this definition"></a></dt>
<dd><p>Compute the unary theta series (weighted by coefficients).</p>
<p>This is a variant of the theta series where terms are weighted by their coefficient values rather than just signs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – Modulus parameter</p></li>
<li><p><strong>r</strong> (<em>int</em>) – Residue class parameter</p></li>
<li><p><strong>max_n</strong> (<em>int</em>) – Maximum summation index</p></li>
<li><p><strong>q</strong> (<em>SymbolicExpression</em>) – Formal variable</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The unary theta series <img class="math" src="_images/math/a2a8d101726dc39a0dc9b2b31775ff45ed8b9ae1.png" alt="\theta_{m,r}(q) = \sum_{n=-\mathrm{max\_n}}^{\mathrm{max\_n}} (r + 2mn) \cdot q^{(r + 2mn)^2/(4m)}"/></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SymbolicExpression</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.indefinite_theta">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">indefinite_theta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_max</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.indefinite_theta" title="Link to this definition"></a></dt>
<dd><p>Compute indefinite theta functions.</p>
<p>Indefinite theta functions are generalizations of classical theta functions to indefinite quadratic forms, important in the theory of mock theta functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>Matrix</em>) – Quadratic form matrix (typically 2×2)</p></li>
<li><p><strong>a</strong> (<em>Vector</em>) – Translation vector</p></li>
<li><p><strong>b</strong> (<em>Vector</em>) – Phase vector</p></li>
<li><p><strong>c1</strong> (<em>Vector</em>) – First sign vector for rho function</p></li>
<li><p><strong>c2</strong> (<em>Vector</em>) – Second sign vector for rho function</p></li>
<li><p><strong>n_max</strong> (<em>int</em>) – Maximum summation range</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The indefinite theta function <img class="math" src="_images/math/5ad4091ea41788f648d3d02382248fcff6524d9e.png" alt="\theta(A,a,b,c_1,c_2) = \sum_n \rho(n+a) \cdot q^{(n+a)^T A(n+a)/2} \cdot \exp(2\pi i n^T Ab)"/></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SymbolicExpression</p>
</dd>
</dl>
<p><strong>Notes:</strong> The rho function <img class="math" src="_images/math/d0e51bd59d8525765740f36dfd146247127f08cd.png" alt="\rho(n) = \text{sign}(c_1^T An) - \text{sign}(c_2^T An)"/> provides the signing that makes the series convergent despite the indefinite form.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.zhat_indefinite_theta">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">zhat_indefinite_theta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.zhat_indefinite_theta" title="Link to this definition"></a></dt>
<dd><p>Compute the Z-hat indefinite theta function.</p>
<p>This is a specialized indefinite theta function that appears in the study of mock theta functions and their modular transformation properties.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – List of three prime parameters</p></li>
<li><p><strong>x</strong> (<em>int</em>) – Primary modular parameter</p></li>
<li><p><strong>r</strong> (<em>int</em>) – Ramanujan parameter</p></li>
<li><p><strong>chi</strong> (<em>int</em>) – Character parameter</p></li>
<li><p><strong>n_max</strong> (<em>int</em>) – Maximum summation range (default: 10)</p></li>
<li><p><strong>nu</strong> (<em>List</em><em>[</em><em>int</em><em>]</em>) – Perturbation parameters (default: [0,0,0])</p></li>
<li><p><strong>c2</strong> (<em>Optional</em><em>[</em><em>Vector</em><em>]</em>) – Optional second sign vector</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The normalized Z-hat function as a power series</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PowerSeries</p>
</dd>
</dl>
<p><strong>Notes:</strong> This function computes a ratio of indefinite theta functions normalized by a Ramanujan theta function, which yields modular objects related to mock theta functions.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.ramanujan_theta">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">ramanujan_theta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_max</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.ramanujan_theta" title="Link to this definition"></a></dt>
<dd><p>Compute Ramanujan’s theta function.</p>
<p>This is a classical theta function that appears in the normalization of various mock theta functions and modular forms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>int</em>) – Modular parameter</p></li>
<li><p><strong>chi</strong> (<em>int</em>) – Character parameter</p></li>
<li><p><strong>n_max</strong> (<em>int</em>) – Maximum summation range</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Ramanujan theta function <img class="math" src="_images/math/57f9ec0a3621743d8547625f45318305f362e470.png" alt="\theta(x,\chi) = \sum_{n=-\mathrm{n\_max}}^{\mathrm{n\_max}} (-1)^n \cdot q^{x/2 \cdot (n - \chi/(2x))^2}"/></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SymbolicExpression</p>
</dd>
</dl>
<p><strong>Notes:</strong> This function is closely related to classical Jacobi theta functions and provides the modular framework for understanding mock theta functions.</p>
</dd></dl>

</section>
<section id="ramanujan-mock-theta-functions">
<h2>Ramanujan Mock Theta Functions<a class="headerlink" href="#ramanujan-mock-theta-functions" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.F0">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">F0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.F0" title="Link to this definition"></a></dt>
<dd><p>Compute Ramanujan’s order 7 mock theta function F0(q).</p>
<p>F0 is one of Ramanujan’s third-order mock theta functions, which exhibit modular-like transformation properties but are not quite modular forms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prec</strong> (<em>int</em>) – Precision (maximum power of q to compute)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><img class="math" src="_images/math/4b45a35cb8e7f60cf9f9a3994ca2be334c9ec25b.png" alt="F_0(q) = \sum_{n \geq 0} \frac{q^{n^2}}{(q^{n+1}; q)_n}"/></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PowerSeries</p>
</dd>
</dl>
<p><strong>Mathematical Definition:</strong> <img class="math" src="_images/math/4b45a35cb8e7f60cf9f9a3994ca2be334c9ec25b.png" alt="F_0(q) = \sum_{n \geq 0} \frac{q^{n^2}}{(q^{n+1}; q)_n}"/> where <img class="math" src="_images/math/18d5ea056b5bef2392132ead9ead1a56faed8a3e.png" alt="(a; q)_n = \prod_{k=0}^{n-1} (1 - aq^k)"/> is the q-Pochhammer symbol.</p>
<p><strong>Notes:</strong> The series is truncated based on the constraint <img class="math" src="_images/math/268d49c26d5128dfb0a74ea51ec31cf2a2bb644b.png" alt="n^2 &lt; \text{prec}"/> to ensure all computed terms are within the desired precision.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.F1">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">F1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.F1" title="Link to this definition"></a></dt>
<dd><p>Compute Ramanujan’s order 7 mock theta function F1(q).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prec</strong> (<em>int</em>) – Precision (maximum power of q to compute)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><img class="math" src="_images/math/544b867ad036dd38b12894cef10261469e03982b.png" alt="F_1(q) = \sum_{n \geq 0} \frac{q^{n^2}}{(q^n; q)_n}"/></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PowerSeries</p>
</dd>
</dl>
<p><strong>Mathematical Definition:</strong> <img class="math" src="_images/math/544b867ad036dd38b12894cef10261469e03982b.png" alt="F_1(q) = \sum_{n \geq 0} \frac{q^{n^2}}{(q^n; q)_n}"/></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.F2">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">F2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.F2" title="Link to this definition"></a></dt>
<dd><p>Compute Ramanujan’s order 7 mock theta function F2(q).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prec</strong> (<em>int</em>) – Precision (maximum power of q to compute)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><img class="math" src="_images/math/f6e7d1297b44e17a8bd67c66705a53ff18906afc.png" alt="F_2(q) = \sum_{n \geq 0} \frac{q^{n^2+n}}{(q^{n+1}; q)_{n+1}}"/></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PowerSeries</p>
</dd>
</dl>
<p><strong>Mathematical Definition:</strong> <img class="math" src="_images/math/f6e7d1297b44e17a8bd67c66705a53ff18906afc.png" alt="F_2(q) = \sum_{n \geq 0} \frac{q^{n^2+n}}{(q^{n+1}; q)_{n+1}}"/></p>
</dd></dl>

</section>
<section id="utility-functions">
<h2>Utility Functions<a class="headerlink" href="#utility-functions" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.format_expansion">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">format_expansion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expansion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.format_expansion" title="Link to this definition"></a></dt>
<dd><p>Format a power series expansion for improved readability.</p>
<p>This function normalizes a power series by factoring out the leading term and presenting it in a more readable form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expansion</strong> (<em>PowerSeries</em>) – The power series to format</p></li>
<li><p><strong>order</strong> (<em>int</em>) – Order for series expansion (default: 20)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted expansion as leading_coeff * q^leading_power * (normalized_series)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>PowerSeries</p>
</dd>
</dl>
<p><strong>Notes:</strong> The function extracts the first coefficient and power, then factors them out to present the series in normalized form.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="d_modularity_revisited.P_poly">
<span class="sig-prename descclassname"><span class="pre">3d_modularity_revisited.</span></span><span class="sig-name descname"><span class="pre">P_poly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#d_modularity_revisited.P_poly" title="Link to this definition"></a></dt>
<dd><p>Load precomputed P polynomial for given parameters.</p>
<p>P polynomials are special polynomials that appear in the study of mock theta functions and their modular properties.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – Primary parameter</p></li>
<li><p><strong>p</strong> (<em>int</em>) – Secondary parameter</p></li>
<li><p><strong>b</strong> (<em>int</em>) – Tertiary parameter</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The P polynomial value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Union[int, SymbolicExpression]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If polynomial with specified parameters is not found</p>
</dd>
</dl>
<p><strong>Notes:</strong> Returns 1 for trivial cases (n &lt; 2 or p = 0). For other cases, looks up precomputed values from the pandas DataFrame.</p>
</dd></dl>

</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<p>[1] Cheng Et Al. 3D Modularity Revisited</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="theorems.html" class="btn btn-neutral float-left" title="Theorems and Conjectures" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="examples.html" class="btn btn-neutral float-right" title="Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, M. Cheng, I. Coman, P. Kucharski, D. Passaro, G. Sgroi.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>